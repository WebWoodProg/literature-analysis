Мартин Р. - Чистый код. Cоздание, анализ и рефакторинг - 2019

## Оглавление
- <a href="#p1">Глава 1. Чистый код</a>
- <a href="#p2">Глава 2. Содержательные имена</a>
- <a href="#p3">Глава 3. Функции</a>
- <a href="#p4">Глава 4. Комментарии</a>
-  <a href="#p5">Глава 5. Форматирование</a>
-  <a href="#p6">Глава 6. Объекты и структуры данных</a>


<h2 id="p1"> Глава 1. Чистый код</h2>

### Краткое содержание:
- Пиши код правильно сразу!
	*Потом равносильно никогда.  -  закон Лебиана.*
- Программист, который подчиняется воле начальника, не понимающего опасность некачественного кода, проявляет непрофессионализм.
- Программисту необходимо развить в себе "Чувство кода" чтобы выбрать лучший вариант и спланировать последовательность преобразований, сохраняющих поведение программы и приводящих к нужному результату.
- Какой код является чистым?
	- "Эффективный" - *Бьерн Страуструп*
	- "Удобочитаемый" - *Грэди Буч*
	- "Грамотный код, упрощающий доработку другим людям." - *"Большой" Дэйв*
	- "Код над которым тщательно поработали"  -  *Майкл Физерс*
	- "Не содержит дубликатов" - *Рон Джеффрис*

<h2 id="p2"> Глава 2. Содержательные имена</h2>

### Краткое содержание
- Имена должны передавать намерения программиста.
- Имя переменной, функции или класса должно отвечать на вопросы почему она существует, что делает, как используется.
- Если имя требует доп. комментариев, значит оно не передает намерений программиста.
	- *ПРИМЕР
	``` java
	if (x[0] == 4)  // плохо
	if (cell[STATUS_VALUE]==FLAGGED) // хорошо
	if (cell.isFlagged()) //лучший вариант
	```
- Избегайте дезинформации
	- *ПРИМЕР*
		не обозначайте группу учетных записей именем accountList, если только она действительно не хранится в списке List. **Лучше accountGroup или accounts**
- Остерегайтесь малозаметных различий в именах
	- *ПРИМЕР*
		XYZControllerForEfficientHandlingOfStrings
		XYZColntrollerForEfficientStorageOfStrings
- Используйте осмысленные различия в именах
	- не создавайте числовые ряды по типу a1, a2, a3, ... , aN. Они не несут информации и представления о намерениях автора.
	``` java
	public static void copyChar (char a1[], char a2[]) //плохо
	public static void copyChar (char source[], char destination[]) //хорошо	
	```
- Не используйте неинформативные слова
	- *ПРИМЕР*
		ProductInfo и ProductData по сути обозначают одно и тоже
- Используйте удобочитаемые имена
	``` java
	// плохой вариант
	class DtaRcrd102 { 
		private Date genymdhms; 
		private Date modymdhms; 
		private final String pszqint = "102"; 
		/* ... */ 
	}; 

	// хороший вариант
	class Customer { 
		private Date generationTimestamp; 
		private Date modificationTimestamp; 
		private final String recordId = "102"; 
		/* ... */ 
	};
	```
- Выбирайте имена удобные для поиска
	``` java
	// плохо
	for (int j=0; j<34; j++) { 
		s += (t[j]*4)/5; 
	} 
	
	// хорошо
	int realDaysPerIdealDay = 4; 
	const int WORK_DAYS_PER_WEEK = 5; 
	int sum = 0; 
	for (int j=0; j < NUMBER_OF_TASKS; j++) { 
		int realTaskDays = taskEstimate[j] * realDaysPerIdealDay; 
		int realTaskWeeks = (realdays / WORK_DAYS_PER_WEEK); 
		sum += realTaskWeeks; 
	}
	```
- Однобуквенные имена могут использоваться только для локальных переменных в коротких методах
- Избегайте схем кодирования имен (например ранее использовался префикс m_  для переменных класса)
	  *ПРИМЕР*
	``` java
	// плохо
	IShapeFactory // интерфейс
	ShapeFactory // реализация

	// хорошо
	ShapeFactory // интерфейс
	ShapeFactoryImp // реализация
	```
- имена классов и объектов должны представлять собой существительные и их комбинации (Customer, WikiPage, ...)
- Старайтесь не использовать слова Manager, Processor, DataInfo.
- Имена методов представляют собой глаголы или глагольные сочетания (postPayment, deletePage, ...)
- При перегрузке конструкторов используйте статические методы - фабрики с именами, описывающими аргументы
	``` java
	Complex fulcrumPoint = Complex.FromRealNumber(23.0); 
	//обычно лучше записи 
	Complex fulcrumPoint = new Complex(23.0);
	```
- Выберите одно слово для каждой концепции (например что то одно из Controller, Manager и Driver)
- Добавьте содержательный контекст
		*ПРИМЕР*
		firstName, lasctName, address, city, state в совокупности понятно что означают адрес, но по отдельности контекст не ясен.
		Рекомендация - создать класс Address и сделать эти данные его полями. Тогда контекст будет ясен.
- Остерегайтесь избыточного контекста
<h2 id="p3"> Глава 3. Функции</h2>

### Краткое содержание
- Функции должны быть максимально компактными
- Блоки в командах if, else, while и т.д. должны состоять из одной строки, в которой обычно содержится вызов функции.
- Функции не должны содержать вложенных структур. Максимальный уровень отступов не должен превышать одного-двух.
- Функция должна выполнять только одну операцию. Она должна выполнять ее хорошо и ничего другого она не должна делать. Если выполняемые действия функции находятся на одном уровне абстракции, то считается что данная функция выполняет одну операцию.
- Код должен читаться сверху вниз (за каждой функцией должны следовать функции следующего уровня абстракции).
- По конструкции switch так и не понял что имел ввиду автор (читать в оригинале)
- Используйте содержательные имена (используйте в именах функций те же словосочетания, глаголы и существительные, которые используются в ваших модулях)
- Чем меньше аргументов в функции тем лучше (максимум 2)
- Не использовать в аргументах флаги, которые говорят функции что делать (true сделай одно, false сделай другое). Разбивать такие функции на две самостоятельные функции.
- Стараться не использовать функции с стремя аргументами
- В случае если функция должна принять больше двух или трех аргументов, упаковываем их в отдельный класс.
	``` java
	Circle makeCircle(double x, double y, double radius); 
	Circle makeCircle(Point center, double radius);
	```
- Если функция с одним аргументом, то она должна образовывать пару глагол/существительное
	``` java
	writeField(name)
	```
- Избавьтесь от побочных эффектов (не делать что-то побочное, скрытое от пользователя)
- Выходных аргументов функции следует избегать. Если ваша функция должна изменять чье-то состояние, пусть она изменяет состояние своего объекта-владельца.
``` java
	public void appendFooter(StringBuffer report)
	
	//лучше будет
	report.appendFooter();
```
- Функция должна что-то делать или отвечать на какой-то вопрос, но не одновременно.
- Используйте исключения вместо возвращения кодов ошибок.
- Изолируйте блоки try/catch (выделять в отдельные функции)
	``` java
	public void delete(Page page) { 
		try { 
			deletePageAndAllReferences(page); 
		} 
		catch (Exception e) { 
			logError(e); 
		} 
	} 
	private void deletePageAndAllReferences(Page page) throws Exception { 
		deletePage(page); 
		registry.deleteReference(page.name); 
		configKeys.deleteKey(page.name.makeKey()); 
	} 
	private void logError(Exception e) { 
		logger.log(e.getMessage()); 
	}
	```
- Обработка ошибок как одна операция (функция, обрабатывающая ошибки, ничего другого делать не должна)
	- если в функции присутствует ключевое слово try, то оно должно быть первым словом в функции, а после блоков catch/finally ничего другого быть не должно (как в предыдущем примере)
- Не старайтесь сразу написать все функции по всем правилам, вероятнее всего у вас это не получится. "Причесывайте" код после его написания.

<h2 id="p4"> Глава 4. Комментарии</h2>

### Краткое содержание
- Комментарии в лучшем случае являются неизбежным злом
	- Проблема кроется в том, что код программы постоянно меняется, эволюционирует, блоки перетекаю из одного место в другое, но не всегда это сопровождается поддержкой комментариев. (поэтому комментарии могут врать).
- Старайтесь делать свой код наиболее выразительным, чтобы комментарии попросту были не нужны.
- Комментарии не должны компенсировать плохой код.
- Объясняйте свои намерения в коде, а не комментариями
	``` java
	// Проверить, положена ли работнику полная премия 
	if ((employee.flags & HOURLY_FLAG) 
		&& (employee.age > 65)) 
		
	// Лучше прописать так (тогда комментарии не нужны) 
	if (employee.isEligibleForFullBenefits())
	```
- Список полезных комментариев:
	- **Юридические комментарии** (например заявление об авторских правах). При этом не нужно перечислять все условия, достаточно указать ссылку на стандартную лицензию или другой внешний документ.
		*ПРИМЕР:*
		``` java
		// Copyright (C) 2003,2004,2005 by Object Mentor, Inc. All rights reserved. 
		// Публикуется на условиях лицензии GNU General Public License версии 2 и выше
		```
	- **Информативные комментарии** (пояснение к коду). Почти всегда есть лучше вариант.
		*ПРИМЕР:*
		``` java
		// Возвращает тестируемый экземпляр Responder. 
		protected abstract Responder responderInstance();
		```
		будет лучше просто переименовать функцию в responderBeingTested
		
		``` java
		// Поиск по формату: kk:mm:ss EEE, MMM dd, yyyy 
		Pattern timeMatcher = Pattern.compile( "\\d*:\\d*:\\d* \\w*, \\w* \\d*, \\d*");
		```
		будет лучше поместить это в специальный класс, преобразующий форматы даты и времени
	- **Представление намерений** 
		( например комментарий типа  
			// Мы пытаемся спровоцировать "состояние гонки", 
			// создавая большое количество программных потоков)
	- **Прояснение** (иногда полезны если не очевидные аргументы возвращаются из какой-то стандартной библиотеки) сложно отследить правильность данного комментария.
		``` java
		public void testCompareTo() throws Exception { 
			WikiPagePath a = PathParser.parse("PageA"); 
			WikiPagePath ab = PathParser.parse("PageA.PageB"); 
			WikiPagePath b = PathParser.parse("PageB"); 
			WikiPagePath aa = PathParser.parse("PageA.PageA"); 
			WikiPagePath bb = PathParser.parse("PageB.PageB");
			WikiPagePath ba = PathParser.parse("PageB.PageA"); 
			assertTrue(a.compareTo(a) == 0); // a == a 
			assertTrue(a.compareTo(b) != 0); // a != b 
			assertTrue(ab.compareTo(ab) == 0); // ab == ab 
			assertTrue(a.compareTo(b) == -1); // a < b 
			assertTrue(aa.compareTo(ab) == -1); // aa < ab 
			assertTrue(ba.compareTo(bb) == -1); // ba < bb 
			assertTrue(b.compareTo(a) == 1); // b > a 
			assertTrue(ab.compareTo(aa) == 1); // ab > aa 
			assertTrue(bb.compareTo(ba) == 1); // bb > ba
		}
		```
	- **Предупреждения о последствиях** 
		``` java
		public static SimpleDateFormat makeStandardHttpDateFormat() { 
			// Класс SimpleDateFormat не является потоково-безопасным, 
			// поэтому экземпляры должны создаваться независимо друг от друга.
			SimpleDateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z"); 
			df.setTimeZone(TimeZone.getTimeZone("GMT")); return df; 
		}
		```
	- **Комментарии TODO** (используется, когда необходимо сделать пометку "что нужно будет сделать в будущем"). Но не загромождать ими код. Необходимо регулярно просматривать их и удалять те, которые потеряли актуальность.
	- **Усиление** (иногда комментарий подчеркивает важность чего либо, что на первый взгляд кажется несущественным).
	- **Общедоступные API** (например Javadoc).
- **Плохие комментарии**
	- комментарии "на скорую руку" понятные только автору
	- избыточные комментарии (комментарий не должен читаться дольше чем сам код)
	- недостоверные комментарии
	- журнальные комментарии (когда что сделали(сейчас для этого есть git))
	- шум (например пояснение что это за переменная или функция)
	- позиционные маркеры (вроде ///////////Действия ////////////)
	- ссылки на автора
	- комментарии за закрывающей фигурной скобкой
	- закомментированный код (удаляйте код, у вас есть коммиты)
	- нелокальная информация (не излагайте информацию системного уровня в контексте локального комментария)
		- *ПРИМЕР*<br>
		//Порт, на котором будет работать fitnesse. По умолчанию 8082
	
	
<h2 id="p5"> Глава 5. Форматирование</h2>

### краткое содержание
Форматирование кода направлено на передачу информации. Стиль кодирования и удобочитаемость создают прецеденты, которые продолжают влиять на сопровождаемость и расширяемость кода.
- Вертикальное форматирование
	- маленькие файлы обычно более понятны, чем большие.
	- используйте пустые строки для визуального разграничения разных концепций в коде.
	- когда необходимо указать тесную связь концепций друг с другом, наоборот необходимо исключить отступы.
	- не выводи в разные файлы концепции тесно связанные друг с другом.
	- локальные переменные должны перечисляться в начале каждой функции (как можно ближе к ней).
	- переменные экземпляров должны объявляться в начале файла.
	- если одна функция вызывает другую, то эти функции должны располагаться вблизи друг от друга по вертикали, а вызывающая функция должна находиться над вызываемой (если это возможно).
- Горизонтальное форматирование
	-  не превышайте длину строки в 120 символов.
	- используйте пробелы для визуального обозначения приоритета операторов.
	- плохая практика
		``` Java
		public FitNesseExpediter(Socket s, 
									FitNesseContext context) throws Exception {
			this.context =            context; 
			socket =                  s; 
			input =                   s.getInputStream(); 
			output =                  s.getOutputStream(); 
			requestParsingTimeLimit = 10000; }
		```
	- хорошая практика
		``` Java
		public FitNesseExpediter(Socket s, FitNesseContext context) throws Exception 
		{ 
			this.context = context; 
			socket = s; 
			input = s.getInputStream(); 
			output = s.getOutputStream(); 
			requestParsingTimeLimit = 10000; 
		}
		```
	- соблюдайте правила табуляции для указания иерархической структуры
	- если программист работает в группе, то должен придерживаться их правилам форматирования

<h2 id="p6"> Глава 6. Объекты и структуры данных</h2>

### краткое содержание
- абстракция данных
	Вместо того, чтобы раскрывать подробности строения данных, используйте представление данных на абстрактном уровне. 
	 Класс не просто ограничивает доступ к переменным через методы чтения/записи Вместо этого он предоставляет абстрактные интерфейсы, посредством которых пользователь оперирует с сущностью данных Знать, как эти данные реализованы, ему при этом не обязательно.
- антисимметрия данных / объектов
     - Объекты скрывают свои данные за абстракциями и предоставляют функции, работающие с этими данными. 
     - Структуры данных раскрывают свои данные и не имеют осмысленных функций.
    - тут лучше читать пример в оригинале (станет понятно)
- закон Деметры
	- закон Деметры гласит, что метод f класса C должен ограничиваться вызовом методов следующих объектов: 
		- C; 
		- объекты, созданные f; 
		- объекты, переданные f в качестве аргумента; 
		- объекты, хранящиеся в переменной экземпляра C 
		Метод не должен вызывать методы объектов, возвращаемых любыми из разрешенных функций. Другими словами, разговаривать можно с друзьями, но не с чужаками.
- не используйте гибриды
	- Гибриды содержат как функции для выполнения важных операций, так и открытые переменные или открытые методы чтения/записи, которые во всех отношениях делают приватные переменные открытыми. Другим внешним функциям предлагается использовать эти переменные так, как в процедурных программах используются структуры данных.
- DTO
    -  Квинтэссенцией структуры данных является класс с открытыми переменными и без функций. Иногда такие структуры называются объектами передачи данных, или DTO (Data Transfer Object). Структуры DTO чрезвычайно полезны, особенно при работе с базами данных, разборе сообщений из сокетов и т .д. С них часто начинается серия фаз преобразования низкоуровневых данных, полученных из базы, в объекты кода приложения
